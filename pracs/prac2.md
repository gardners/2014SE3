Practical 2 -- finding regressions using GIT
============================================

Today's prac consists of using the git bisect command to search through the history of a repository to discover when a regression was introduced.

Source control makes this possible, because all versions of each source file are retained.

Good source control tools make it easy, by optimising and facilitating the search through the commit history.

GIT provides the 'bisect' facility, where you can specify the range of commits you want to search through, and then have GIT prompt you as to which commit you should next test.  GIT uses a binary search, so 2^n commits can be tested using only n steps.  For 1,000 commits, this would be about 10 steps -- a significant time saving!

For further reading, refer to http://git-scm.com/docs/git-bisect

Getting started
---------------

Begin by making sure you have cloned this repository into a convenient place. If not, you can clone it now with commands like:

    git clone git://github.com/YOURGITHUBUSERNAME/2014SE3
    cd 2014SE3

If you already have your own fork of the 2014SE3 repository, then you will need to pull the changes from the master repository to your local copy with something like:

    git checkout master
    git pull git://github.com/gardners/2014SE3

You probably want to push that back onto your fork of the repository github:

    git push origin

Choosing which exercise to do
-----------------------------

In the `pracs/prac2/students` directory there are several numbered directories.  

Choose one randomly to use.  Well, that's the idea.  Some are probably better than others.  2 is a good one.  I had intended for there to be enough for each student to work on a different one, but that hasn't worked out.  So be good cherubs and make sure you do the work yourself.  I may visit your terminal when marking off checkpoints to ensure that you have done your own work.

Inside each directory there is a file, `mutated.c`, that is the program we are testing to determine which commit caused it to begin failing tests.  

Each `mutated.c` file has been generated by moving lines around within a working program.  There will be a number such changes that do not cause the program to fail tests, followed by at least one commit that introduces an error, causing it to fail at least one test.  

You can explore the history of your chosen `mutated.c` from the github web interface by navigating to the appropriate directory, clicking on the file, and then clicking on "history" to see the list of commits.  Clicking on each commit will show the simple change made in that commit. 

You can also explore the history from the command line using a command like:

    git log pracs/prac2/students/6/mutated.c
    
That command will show all commits that modified the file `pracs/prac2/students/6/mutated.c`.  Make sure to replace the file name with the one you are interested in!

Before we go any further, you should compile the test framework with a command like:

    gcc -Wall -g -o test pracs/prac2/students/template/test.c -lnsl -lsocket
    
This only needs to be done once.  If you do it again during the bisect, you will compile old versions of the test framework, which is not what we want to do in this case.

Starting to bisect
------------------

From in your `2014SE3` directory, run the following git command to tell it you want to start bisecting:

    git bisect reset
    git bisect start pracs/prac2/students/6
    git bisect bad
    
This tells git that you only care about commits that modify files in the `pracs/prac2/students/6` directory, and that the latest commit is bad.

Now you need to tell git about a commit that is good.  Use a command like the following (but remember to change the filename to match the one you are using) to get the history of the `mutated.c` file you are working on:

    git log pracs/prac2/students/2/mutated.c
    
This will display a block of output for each commit.  There may be many or few commits for the example you are using.  The newest commit will be at the top, and the oldest at the bottom.  You may need to press SPACE a few times for it to scroll to the end of the list.  

At the end of the list, look for the last line that begins with `commit`.  It will be followed by a long hexadecimal number.  That number is the unique identifier for that commit.  Use the mouse to select it, so that you can paste it into a git command in a moment.  Once done, you can press Q to exit back to the shell.

Now type `git bisect good `, and then paste that hexidecimal string onto the end of the command, and press ENTER.

You should then see output including something like:

    Bisecting: 20 revisions left to test after this (roughly 4 steps)
    
If you see something like the following:

    error: Your local changes to the following files would be overwritten by checkout:
	    pracs/prac2/students/5/mutated.c
	    pracs/prac2/students/6/mutated.c
    Please, commit your changes or stash them before you can switch branches.
    Aborting
    
You need to clean up your repository.  Something like:

    git reset --hard origin/master
    
Will reset it back to whatever you last pushed to github.

You are now ready to test each commit that git bisect suggests.

Testing the commits to find the first bad one
---------------------------------------------

To test a commit, you need to have compile the version of mutated.c.  You can do this with the following command:

    gcc -Wall -g -o mutated pracs/prac2/students/3/mutated.c -lnsl -lsocket
    
Again, don't forget to substitute the correct directory for the second command.

If compilation succeeds, you can now run the test suite on this version of `mutated.c` and see how it fares:

    ./test ./mutated
    
It can take a couple of minutes to run, and should produce output similar to that below:

    connect() to port failed: Connection refused
    Port 49050 is available for use by student programme.
    connect() to port failed: Connection refused
    SUCCESS: Accepts connections on specified TCP port
    FAIL: Accepting multiple connections on a TCP port. Did not complete 1,000 connections in less than 5 minutes.
    SUCCESS: Accepted 1,000 connections in less than a minute.
    SUCCESS: HTTP request 'GET / HTTP/1.0\r\n\r\n' returned HTTP response code 200
    SUCCESS: HTTP request 'GET / HTTP/1.0\r\r' returned HTTP response code 200

    The HTTP request does not end in two carriage returns. Waiting for timeout...
    SUCCESS: HTTP request 'GET / HTTP/1.0' returned nothing, a dropped connection or HTTP request timeout indication.

    The HTTP request does not end in two carriage returns. Waiting for timeout...
    SUCCESS: HTTP request 'GET / HTTP/1.0\r\n' returned nothing, a dropped connection or HTTP request timeout indication.

    The client has requested FTP. Sending error.
    SUCCESS: HTTP request 'GET / FTP/1.0\r\n\r\n' correctly reported an HTTP error

    The client has requested the wrong version of HTTP. Sending error.
    SUCCESS: HTTP request 'GET / HTTP/1.1\r\n\r\n' correctly reported an HTTP error

    The client has requested a page. Reporting a 404 error.

    The page request does not end in two carriage returns. Waiting for timeout...
    SUCCESS: HTTP request 'GET /this_page_should_not_exist HTTP/1.0\r\n\r\n' returned HTTP response code 404
    SUCCESS: Response includes valid and correct content-length field

    tcp port did not respond
    FAIL: Fails to make outbound TCP connection on specified port.
    FAIL: Other tests suppressed due to dependence on the above.
    Passed 10 of 25 tests.
    Score for functional aspects of assignment 1 will be 33%.
    Score for style (0% -- 16%) will be assessed manually.
    Therefore your grade for this assignment will be in the range 33% -- 49% (F -- F)
    About to kill student process 16283
    Seeing how that went.

If compilation failed, or less than 24 of 25 tests pass, then tell git that it is a bad commit with:

    git bisect bad
    
Similarly, if it takes too long to run (more than about a minute), then just press CONTROL and C to tell it to stop, and then issue the `git bisect bad` command.

If, on the other hand, 24 or 25 of 25 tests pass, then tell git that this version is good, with `git bisect good`

Repeat this process (from the start of "Testing the commits to find the first bad one"), i.e., compiling and running the tests, and then entering either `git bisect good` or `git bisect bad` based on the test results until git shows you something like:

    b33abc3702f514e034ff106eed955210acc3e398 is the first bad commit
    commit b33abc3702f514e034ff106eed955210acc3e398
    Author: gardners <paul@servalproject.org>
    Date:   Thu Mar 20 11:06:54 2014 +1030

        Uninformative commit message

    :040000 040000 96fbdfaf07f0f2339880e2c39999b9ec54f2a349 eaa9d4f511825d769f8a70c1916b0cd31f189cc0 M      pracs

The first line `b33abc3702f514e034ff106eed955210acc3e398 is the first bad commit` is the important one, telling you the first commit that is bad.

Finishing up
------------

Now that you know the first bad commit, you can work out the last good commit by looking through the git history with `git log`

In the `git log` listing, search for the first bad commit by typing a / followed by the first few characters of the commit and pressing ENTER.

Using the commit b33abc37... above, this will display a screen beginning with something like:

    commit b33abc3702f514e034ff106eed955210acc3e398
    Author: gardners <paul@servalproject.org>
    Date:   Thu Mar 20 11:04:14 2014 +1030

        Uninformative commit message

    commit 772a6ba9889f0832f5553dbdca598d302b686ab1
    Author: gardners <paul@servalproject.org>
    Date:   Thu Mar 20 11:03:51 2014 +1030

        Uninformative commit message

b33abc3... is the first bad commit, and 772a6ba... is the previous commit, so it must be the last good commit.

You now need to prove this, and produce documentation to show this so that you can submit a bug report.

Now on github, you need to submit an issue onto my master 2014SE3 repository.

The following tells you the general content you should put in the issue, but you should make sure that it "tells the story", i.e., that you have detected a regression, and identified the first bad commit, and presenting the test results for the last good commit and first bad commit as evidence.  You can see the sort of thing I am looking for at: https://github.com/gardners/2014SE3/issues/25

To get the indented text blocks, put four spaces at the beginning of each line of text you paste in.  The commit IDs will automatically be turned into links.

For each of those two commits, you will want to check them out using `git checkout commmit_id`, where `commit_id` is replaced with the commit (or the first few characters of it), e.g.:

    git checkout b33abc3
    
This will display something like

    Note: checking out 'b33abc3702f514e034ff106eed955210acc3e398'.

    You are in 'detached HEAD' state. You can look around, make experimental
    changes and commit them, and you can discard any commits you make in this
    state without impacting any branches by performing another checkout.

    If you want to create a new branch to retain commits you create, you may
    do so (now or later) by using -b with the checkout command again. Example:

        git checkout -b new_branch_name

    HEAD is now at b33abc3... Uninformative commit message
    
What this all means is that you have checked out the program at a point in the past, but they won't affect the recorded future, and you might have trouble getting any such changes back again unless you re-checked them out as a branch.
    
Then compile the program again, so that you can show that some of the tests fail:

    gcc -Wall -g -o mutated pracs/prac2/students/3/mutated.c -lnsl -lsocket
    
(again, don't forget to use the right path in this command!)

And then run the tests again:

    ./test ./mutated

Copy and paste the output of the above command into the issue and appropriately describe and contextualise it.

Repeat the same process for the other commit.  Don't forget to indicate which is the last good commit (and give the commit ID) and the same for the first bad commit.

When you are satisfied that the issue is ready, submit it.  If I am happy with it, you will receive this weeks checkpoint.
